<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>OSM + Leaflet + Geoapify Routes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  
  <!-- Add DNS prefetch hints -->
  <link rel="dns-prefetch" href="https://unpkg.com">
  <link rel="dns-prefetch" href="https://tile.openstreetmap.org">
  <link rel="dns-prefetch" href="https://api.geoapify.com">
  <link rel="dns-prefetch" href="https://api.open-meteo.com">
  <link rel="dns-prefetch" href="https://raw.githubusercontent.com">
  
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    body { font-family: 'Roboto', Arial, sans-serif; }
    #map { z-index: 1; }
    .floating-card { position: absolute; bottom: 20px; left: 20px; right: 20px; width: auto; max-width: 420px; background: #f8f9ff; border-radius: 18px; box-shadow: 0 4px 24px rgba(64,71,109,0.15), 0 2px 8px rgba(64,71,109,0.1); z-index: 1001; padding: 22px 22px 18px 22px; display: flex; flex-direction: column; gap: 14px; transition: all 0.3s ease; border: 1px solid rgba(220,225,245,0.7); }
    .floating-card.minimized { width: 56px; height: 56px; border-radius: 28px; bottom: 20px; left: 20px; right: auto; padding: 0; overflow: hidden; transform: scale(0.95); background: #5e72e4; box-shadow: 0 4px 12px rgba(94,114,228,0.3); border: none; }
    .input-row { display: flex; gap: 10px; align-items: center; position: relative; margin-bottom: 4px; }
    .input-row input { flex: 1; padding: 12px 16px; border-radius: 10px; border: 1px solid #dce1f1; font-size: 15px; background: #ffffff; box-shadow: inset 0 1px 3px rgba(64,71,109,0.05); transition: all 0.2s ease; }
    .input-row input:focus { border-color: #5e72e4; background: #fff; outline: none; box-shadow: 0 0 0 3px rgba(94,114,228,0.15); }
    .input-row button { width: 36px; height: 36px; border: none; border-radius: 50%; background: #5e72e4; color: #fff; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .input-row button:active { background: #4756ca; }
    .swap-btn { background: #eef0fa !important; color: #5e72e4 !important; }
    .route-actions { display: flex; gap: 12px; justify-content: space-between; margin-top: 6px; }
    .route-actions button { flex: 1; padding: 12px 0; border-radius: 10px; font-size: 15px; border: none; background: #5e72e4; color: white; font-weight: 600; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 6px rgba(94,114,228,0.3); }
    .route-actions button:hover:not(:disabled) { background: #4756ca; transform: translateY(-1px); box-shadow: 0 4px 8px rgba(94,114,228,0.4); }
    .route-actions button:active:not(:disabled) { transform: translateY(1px); box-shadow: 0 1px 4px rgba(94,114,228,0.2); }
    .route-actions button:disabled { opacity: 0.5; cursor: not-allowed; }
    #navBtn { background: #11cdef; box-shadow: 0 2px 6px rgba(17,205,239,0.3); }
    #navBtn:hover:not(:disabled) { background: #0fb5d1; box-shadow: 0 4px 8px rgba(17,205,239,0.4); }
    #routeInfo { position: absolute; bottom: 240px; left: 10px; right: 10px; width: auto; max-width: 420px; margin: 0 auto; background: #f8f9ff; border-radius: 12px; box-shadow: 0 4px 16px rgba(64,71,109,0.18); z-index: 1001; padding: 14px 18px; font-size: 15px; display: none; border: 1px solid rgba(220,225,245,0.7); transition: bottom 0.3s ease; }
    #routeInfo.card-minimized { bottom: 90px; }
    .minimize-btn { position: absolute; top: -15px; right: 15px; width: 30px; height: 30px; background: #fb6340; color: white; border: 2px solid white; border-radius: 50%; font-size: 16px; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 1002; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
    .floating-card.minimized .minimize-btn { top: 50%; left: 50%; right: auto; transform: translate(-50%, -50%); background: transparent; border: none; box-shadow: none; font-size: 24px; }
    .floating-card.minimized .card-content { display: none; }
    .autocomplete-dropdown { position: absolute; top: 100%; left: 0; right: 0; background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); margin-top: 4px; max-height: 200px; overflow-y: auto; z-index: 1005; display: none; border: 1px solid #ddd; }
    .autocomplete-item { padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0; font-size: 14px; }
    .autocomplete-item:last-child { border-bottom: none; }
    .autocomplete-item:hover, .autocomplete-item:focus { background-color: #f0f8ff; outline: none; }
    .autocomplete-main { font-weight: bold; display: block; margin-bottom: 2px; }
    .autocomplete-secondary { color: #666; font-size: 12px; }
    .weather-container { position: absolute; top: 20px; right: 20px; background: #f8f9ff; border-radius: 12px; box-shadow: 0 4px 16px rgba(64,71,109,0.15); z-index: 1000; padding: 12px 14px; max-width: 180px; display: none; border: 1px solid rgba(220,225,245,0.7); transition: all 0.3s ease; }
    .weather-header { display: flex; justify-content: space-between; font-weight: 600; margin-bottom: 8px; font-size: 14px; }
    .weather-details { display: flex; align-items: center; gap: 10px; }
    .weather-icon { font-size: 32px; line-height: 1; }
    .weather-data { display: flex; flex-direction: column; font-size: 13px; }
    #weatherDesc { margin-bottom: 4px; }
    #weatherExtra { font-size: 12px; color: #555; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="floating-card" id="floatingCard">
    <div class="card-content" id="cardContent">
      <div class="input-row">
        <input id="startInput" type="text" placeholder="Starting point (address or 'My location')" autocomplete="off"/>
        <button id="startLocBtn" title="Use my location">üìç</button>
        <div id="startAutocomplete" class="autocomplete-dropdown"></div>
      </div>
      <div class="input-row">
        <input id="destInput" type="text" placeholder="Destination" autocomplete="off"/>
        <button id="destLocBtn" title="Use my location as destination">üìç</button>
        <button id="swapBtn" class="swap-btn" title="Swap start and destination">‚áÖ</button>
        <div id="destAutocomplete" class="autocomplete-dropdown"></div>
      </div>
      <div class="route-actions">
        <button id="routeBtn" disabled>Route</button>
        <button id="navBtn" disabled>Navigate</button>
      </div>
    </div>
    <button class="minimize-btn" id="toggleBtn">‚Üï</button>
  </div>
  <div id="routeInfo"></div>
  <div id="weatherInfo" class="weather-container">
    <div class="weather-header">
      <span id="weatherLocation">Weather</span>
      <span id="weatherTemp"></span>
    </div>
    <div class="weather-details">
      <div id="weatherIcon"></div>
      <div class="weather-data">
        <div id="weatherDesc"></div>
        <div id="weatherExtra"></div>
      </div>
    </div>
  </div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Bridge for communication with React Native
    window.receiveLocationFromApp = function(locationData) {
      console.log('Received location from app:', locationData);
      
      if (!locationData.success) {
        // Handle error
        if (locationData.purpose === 'start') {
          startLocBtn.textContent = 'üìç';
        } else if (locationData.purpose === 'dest') {
          destLocBtn.textContent = 'üìç';
        }
        alert('Location error: ' + locationData.error);
        return;
      }
      
      // Store the user location
      userLatLng = {
        lat: locationData.latitude,
        lng: locationData.longitude
      };
      
      // Handle based on the purpose
      if (locationData.purpose === 'start') {
        setMarker(locationData.latitude, locationData.longitude, 'start', true);
        startInput.value = "My location";
        startLocBtn.textContent = 'üìç';
        isUsingCurrentLocation = true;
        updateButtons();
      } 
      else if (locationData.purpose === 'dest') {
        setMarker(locationData.latitude, locationData.longitude, 'dest', true);
        destInput.value = "My location";
        destLocBtn.textContent = 'üìç';
      }
      else if (locationData.purpose === 'initial') {
        // Just center the map for initial load
        map.setView([locationData.latitude, locationData.longitude], 15);
        
        // Also add location as a point of interest that can be rated
        addPointOfInterest(
          locationData.latitude, 
          locationData.longitude, 
          "My Current Location",
          "Your current position"
        );
      }
      
      // Update weather with the new location
      getWeatherData(locationData.latitude, locationData.longitude);
    };

    // Function to request location from React Native
    function requestLocationFromApp(purpose) {
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'requestLocation',
          purpose: purpose
        }));
        return true;
      }
      return false;
    }
    
    // Function to add a point of interest that can be rated
    function addPointOfInterest(lat, lng, name, description = '') {
      const iconUrl = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png';
      const icon = L.icon({
        iconUrl, 
        iconSize: [25, 41], 
        iconAnchor: [12, 41], 
        popupAnchor: [1, -34]
      });
      
      const marker = L.marker([lat, lng], {icon}).addTo(map);
      
      // Create the popup content with a rating button
      const popupContent = `
        <div style="min-width: 200px; padding: 5px; text-align: center;">
          <h3 style="margin: 0 0 8px 0; font-size: 16px;">${name || 'Unnamed Location'}</h3>
          ${description ? `<p style="margin: 0 0 10px 0; font-size: 13px;">${description}</p>` : ''}
          <button 
            onclick="openLocationDetail(${lat}, ${lng}, '${name.replace(/'/g, "\\'")}')"
            style="background: #5e72e4; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; width: 100%; transition: all 0.2s ease;"
            onmouseover="this.style.backgroundColor='#4756ca'"
            onmouseout="this.style.backgroundColor='#5e72e4'"
          >
            View Details & Rate Location
          </button>
        </div>
      `;
      
      marker.bindPopup(popupContent);
      return marker;
    }
    
    // Function to open location detail (rating) page
    function openLocationDetail(lat, lng, name) {
      if (window.ReactNativeWebView) {
        // Send location data to React Native
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'openLocationDetail',
          latitude: lat,
          longitude: lng,
          name: name || 'Location Details'
        }));
      } else {
        console.log('Would navigate to location details:', {lat, lng, name});
      }
    }
  </script>
  <script>
    const GEOAPIFY_KEY = "84bd4ab6f40147c580e54185d36db93d";
    let map = L.map('map').setView([15.6942, 120.4132], 13);
    let startMarker, destMarker, routeLine, navStep = 0, navSteps = [];
    let userLatLng = null, isUsingCurrentLocation = false;
    let startAutocompleteTimer = null, destAutocompleteTimer = null;

    // UI Elements
    const startInput = document.getElementById('startInput');
    const destInput = document.getElementById('destInput');
    const routeBtn = document.getElementById('routeBtn');
    const navBtn = document.getElementById('navBtn');
    const startLocBtn = document.getElementById('startLocBtn');
    const destLocBtn = document.getElementById('destLocBtn');
    const swapBtn = document.getElementById('swapBtn');
    const routeInfo = document.getElementById('routeInfo');
    const centerMapBtn = document.getElementById('centerMapBtn');
    const startAutocomplete = document.getElementById('startAutocomplete');
    const destAutocomplete = document.getElementById('destAutocomplete');
    const floatingCard = document.getElementById('floatingCard');
    const toggleBtn = document.getElementById('toggleBtn');
    const cardContent = document.getElementById('cardContent');

    // Add tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '¬© OpenStreetMap contributors'
    }).addTo(map);

    // Toggle floating card minimize/expand
    toggleBtn.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      floatingCard.classList.toggle('minimized');
      
      if (floatingCard.classList.contains('minimized')) {
        toggleBtn.innerHTML = 'üìã'; // Document/expand icon when minimized
        toggleBtn.title = "Show route panel";
        
        // If routeInfo is visible, adjust its position
        if (routeInfo.style.display === 'block') {
          routeInfo.style.bottom = '90px';
        }
      } else {
        toggleBtn.innerHTML = '&times;'; // √ó symbol for minimize/close
        toggleBtn.title = "Minimize panel";
        
        // If routeInfo is visible, adjust its position
        if (routeInfo.style.display === 'block') {
          routeInfo.style.bottom = '240px';
        }
      }
    });

    // Also prevent clicks on the button from triggering input fields
    toggleBtn.addEventListener('mousedown', function(e) {
      e.preventDefault();
      e.stopPropagation();
    });

    // Route button minimizes the card automatically
    routeBtn.addEventListener('click', function() {
      if (!startMarker || !destMarker) {
        alert('Set both start and destination!');
        return;
      }
      
      // Calculate route first
      calculateRoute();
      
      // Then minimize the card
      setTimeout(() => {
        floatingCard.classList.add('minimized');
        toggleBtn.textContent = '‚Üë';
      }, 300);
    });

    // Get autocomplete suggestions
    function getAutocompleteSuggestions(text, dropdownElement, isStart) {
      if (!text || text.trim().length < 2 || text.toLowerCase() === "my location") {
        dropdownElement.style.display = 'none';
        return;
      }
      
      dropdownElement.innerHTML = '<div class="autocomplete-item">Loading suggestions...</div>';
      dropdownElement.style.display = 'block';
      
      const url = `https://api.geoapify.com/v1/geocode/autocomplete?text=${encodeURIComponent(text)}&apiKey=${GEOAPIFY_KEY}`;
      const requestOptions = { method: 'GET' };
      
      fetch(url, requestOptions)
        .then(response => response.json())
        .then(result => {
          if (result && result.features && result.features.length > 0) {
            dropdownElement.innerHTML = '';
            
            result.features.forEach(feature => {
              const properties = feature.properties;
              const item = document.createElement('div');
              item.className = 'autocomplete-item';
              item.setAttribute('tabindex', '0');
              
              const mainName = properties.formatted || properties.name || "Address";
              let secondaryDetails = '';
              if (properties.city || properties.state || properties.country) {
                const parts = [];
                if (properties.city && !mainName.includes(properties.city)) parts.push(properties.city);
                if (properties.state && !mainName.includes(properties.state)) parts.push(properties.state);
                if (properties.country) parts.push(properties.country);
                secondaryDetails = parts.join(', ');
              }
              
              item.innerHTML = `<span class="autocomplete-main">${mainName}</span>${secondaryDetails ? `<span class="autocomplete-secondary">${secondaryDetails}</span>` : ''}`;
              
              item.addEventListener('click', () => {
                if (feature.geometry && feature.geometry.coordinates) {
                  const [lng, lat] = feature.geometry.coordinates;
                  
                  if (isStart) {
                    startInput.value = mainName;
                    setMarker(lat, lng, 'start', false);
                  } else {
                    destInput.value = mainName;
                    setMarker(lat, lng, 'dest', false);
                  }
                }
                dropdownElement.style.display = 'none';
              });
              
              dropdownElement.appendChild(item);
            });
            
            dropdownElement.style.display = 'block';
          } else {
            dropdownElement.innerHTML = '<div class="autocomplete-item">No matching places found</div>';
          }
        })
        .catch(error => {
          console.error('Autocomplete error:', error);
          dropdownElement.innerHTML = `<div class="autocomplete-item">Error: ${error.message}</div>`;
        });
    }

    // Set up autocomplete for inputs
    startInput.addEventListener('input', function() {
      if (startAutocompleteTimer) clearTimeout(startAutocompleteTimer);
      startAutocompleteTimer = setTimeout(() => getAutocompleteSuggestions(this.value, startAutocomplete, true), 200);
    });
    
    destInput.addEventListener('input', function() {
      if (destAutocompleteTimer) clearTimeout(destAutocompleteTimer);
      destAutocompleteTimer = setTimeout(() => getAutocompleteSuggestions(this.value, destAutocomplete, false), 200);
    });

    // Helper: Set marker
    function setMarker(lat, lng, type, isCurrentLocation = false) {
      const iconUrl = type === 'start'
        ? 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png'
        : 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png';
      const icon = L.icon({
        iconUrl, iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34]
      });
      
      if (type === 'start') {
        if (startMarker) map.removeLayer(startMarker);
        startMarker = L.marker([lat, lng], {icon, draggable: true}).addTo(map);
        
        // Make the popup content more useful
        const popupContent = isCurrentLocation ? 
          `<b>My location (start)</b><br>Latitude: ${lat.toFixed(5)}<br>Longitude: ${lng.toFixed(5)}` : 
          `<b>Start point</b><br>Latitude: ${lat.toFixed(5)}<br>Longitude: ${lng.toFixed(5)}`;
        startMarker.bindPopup(popupContent).openPopup();
        
        startMarker.on('dragend', () => {
          const pos = startMarker.getLatLng();
          startInput.value = `${pos.lat.toFixed(5)},${pos.lng.toFixed(5)}`;
          isUsingCurrentLocation = false;
          updateButtons();
        });
        
        // Track if we're using current location
        isUsingCurrentLocation = isCurrentLocation;
      } else {
        if (destMarker) map.removeLayer(destMarker);
        destMarker = L.marker([lat, lng], {icon, draggable: true}).addTo(map);
        
        // Make the popup content more useful
        const popupContent = isCurrentLocation ? 
          `<b>My location (destination)</b><br>Latitude: ${lat.toFixed(5)}<br>Longitude: ${lng.toFixed(5)}` : 
          `<b>Destination</b><br>Latitude: ${lat.toFixed(5)}<br>Longitude: ${lng.toFixed(5)}`;
        destMarker.bindPopup(popupContent).openPopup();
        
        destMarker.on('dragend', () => {
          const pos = destMarker.getLatLng();
          destInput.value = `${pos.lat.toFixed(5)},${pos.lng.toFixed(5)}`;
          updateButtons();
        });
      }
      
      map.setView([lat, lng], 15);
      updateButtons();
    }

    // Update route & navigation buttons state
    function updateButtons() {
      routeBtn.disabled = !(startMarker && destMarker);
      
      // Only enable navigate button when start is current location
      navBtn.disabled = !(startMarker && destMarker && isUsingCurrentLocation);
      
      // Clear any existing route
      if (routeLine) { 
        map.removeLayer(routeLine); 
        routeLine = null; 
      }
      
      routeInfo.style.display = 'none';
    }

    // My location for start
    startLocBtn.onclick = function() {
      startLocBtn.textContent = '‚åõ';
      if (!requestLocationFromApp('start')) {
        // Fallback for browser testing
        if (!navigator.geolocation) {
          alert('Geolocation not supported');
          startLocBtn.textContent = 'üìç';
          return;
        }
        
        navigator.geolocation.getCurrentPosition(pos => {
          const {latitude, longitude} = pos.coords;
          userLatLng = {lat: latitude, lng: longitude};
          setMarker(latitude, longitude, 'start', true);
          startInput.value = "My location";
          startLocBtn.textContent = 'üìç';
          isUsingCurrentLocation = true;
          updateButtons();
        }, err => {
          alert('Location error: ' + err.message);
          startLocBtn.textContent = 'üìç';
        });
      }
    };
    
    // My location for destination
    destLocBtn.onclick = function() {
      destLocBtn.textContent = '‚åõ';
      if (!requestLocationFromApp('dest')) {
        // Fallback for browser testing
        if (!navigator.geolocation) {
          alert('Geolocation not supported');
          destLocBtn.textContent = 'üìç';
          return;
        }
        
        navigator.geolocation.getCurrentPosition(pos => {
          const {latitude, longitude} = pos.coords;
          userLatLng = {lat: latitude, lng: longitude};
          setMarker(latitude, longitude, 'dest', true);
          destInput.value = "My location";
          destLocBtn.textContent = 'üìç';
        }, err => {
          alert('Location error: ' + err.message);
          destLocBtn.textContent = 'üìç';
        });
      }
    };

    // Geocode inputs on blur
    startInput.onblur = function() {
      // Skip if using autocomplete or "My location"
      if (startAutocomplete.style.display === 'block' || 
          startInput.value.trim().toLowerCase() === "my location") {
        return;
      }
      
      // Handle coordinate format
      if (startInput.value.trim().match(/^-?\d+(\.\d+)?,-?\d+(\.\d+)?$/)) {
        const [lat, lng] = startInput.value.trim().split(',').map(Number);
        setMarker(lat, lng, 'start', false);
      } else if (startInput.value.trim()) {
        // Geocode the address
        const url = `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(startInput.value.trim())}&apiKey=${GEOAPIFY_KEY}`;
        fetch(url)
          .then(r => r.json())
          .then(data => {
            if (data.features && data.features.length) {
              const [lng, lat] = data.features[0].geometry.coordinates;
              setMarker(lat, lng, 'start', false);
            }
          });
      }
    };
    
    destInput.onblur = function() {
      // Skip if using autocomplete or "My location"
      if (destAutocomplete.style.display === 'block' || 
          destInput.value.trim().toLowerCase() === "my location") {
        return;
      }
      
      // Handle coordinate format
      if (destInput.value.trim().match(/^-?\d+(\.\d+)?,-?\d+(\.\d+)?$/)) {
        const [lat, lng] = destInput.value.trim().split(',').map(Number);
        setMarker(lat, lng, 'dest', false);
      } else if (destInput.value.trim()) {
        // Geocode the address
        const url = `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(destInput.value.trim())}&apiKey=${GEOAPIFY_KEY}`;
        fetch(url)
          .then(r => r.json())
          .then(data => {
            if (data.features && data.features.length) {
              const [lng, lat] = data.features[0].geometry.coordinates;
              setMarker(lat, lng, 'dest', false);
            }
          });
      }
    };

    // Swap start and destination
    swapBtn.onclick = function() {
      const tmpValue = startInput.value;
      startInput.value = destInput.value;
      destInput.value = tmpValue;
      
      // Swap the markers if they exist
      if (startMarker && destMarker) {
        const startPos = startMarker.getLatLng();
        const destPos = destMarker.getLatLng();
        
        // Remember if start was current location
        const wasCurrentLocation = isUsingCurrentLocation;
        
        // Swap markers
        setMarker(destPos.lat, destPos.lng, 'start', false);
        setMarker(startPos.lat, startPos.lng, 'dest', wasCurrentLocation);
        
        // Update isUsingCurrentLocation
        isUsingCurrentLocation = false;
        updateButtons();
      }
    };

    // Set start/dest marker on map click
    map.on('click', function(e) {
      if (!startMarker) {
        // First click sets start
        setMarker(e.latlng.lat, e.latlng.lng, 'start', false);
        startInput.value = `${e.latlng.lat.toFixed(5)},${e.latlng.lng.toFixed(5)}`;
      } else if (!destMarker) {
        // Second click sets destination
        setMarker(e.latlng.lat, e.latlng.lng, 'dest', false);
        destInput.value = `${e.latlng.lat.toFixed(5)},${e.latlng.lng.toFixed(5)}`;
      } else {
        // Subsequent clicks update start
        setMarker(e.latlng.lat, e.latlng.lng, 'start', false);
        startInput.value = `${e.latlng.lat.toFixed(5)},${e.latlng.lng.toFixed(5)}`;
      }
    });

    // Calculate and display route
    function calculateRoute() {
      if (!startMarker || !destMarker) return;
      
      const s = startMarker.getLatLng();
      const d = destMarker.getLatLng();
      
      // Get weather for the destination
      getWeatherData(d.lat, d.lng);
      
      // Show loading message
      routeInfo.innerHTML = "Calculating route...";
      routeInfo.style.display = 'block';
      
      // Set proper position class based on floating card state
      if (floatingCard.classList.contains('minimized')) {
        routeInfo.classList.add('card-minimized');
      } else {
        routeInfo.classList.remove('card-minimized');
      }
      
      const url = `https://api.geoapify.com/v1/routing?waypoints=${s.lat},${s.lng}|${d.lat},${d.lng}&mode=drive&apiKey=${GEOAPIFY_KEY}`;
      
      fetch(url)
        .then(r => r.json())
        .then(data => {
          if (routeLine) map.removeLayer(routeLine);
          
          if (data.features && data.features.length) {
            // Extract route geometry
            const routeGeometry = data.features[0].geometry;
            let routeCoords = [];
            
            if (routeGeometry.type === 'LineString') {
              routeCoords = routeGeometry.coordinates.map(coord => [coord[1], coord[0]]);
            } else if (routeGeometry.type === 'MultiLineString') {
              routeGeometry.coordinates.forEach(line => {
                routeCoords = routeCoords.concat(line.map(coord => [coord[1], coord[0]]));
              });
            }
            
            // Create route line
            routeLine = L.polyline(routeCoords, { 
              color: '#2196F3', 
              weight: 6,
              opacity: 0.7,
              lineCap: 'round',
              lineJoin: 'round'
            }).addTo(map);
            
            // Get route properties
            let props = data.features[0].properties;
            const distance = (props.distance / 1000).toFixed(2);
            const timeMin = Math.round(props.time / 60);
            
            // Display route info
            routeInfo.innerHTML = `<b>Distance:</b> ${distance} km<br><b>Time:</b> ${timeMin} min`;
            routeInfo.style.display = 'block';
            
            // Extract navigation steps if available
            navSteps = [];
            if (props.legs && props.legs[0] && props.legs[0].steps) {
              navSteps = props.legs[0].steps;
            }
            
            // Update nav button
            navBtn.disabled = !(navSteps.length > 0 && isUsingCurrentLocation);
            
            // Fit map to show the route
            map.fitBounds(routeLine.getBounds(), { padding: [40, 40] });
          } else {
            routeInfo.innerHTML = "No route found between these points.";
          }
        })
        .catch(error => {
          console.error("Routing error:", error);
          routeInfo.innerHTML = "Error calculating route. Please try again.";
        });
    }

    // Navigation handling
    navBtn.onclick = function() {
      if (!navSteps.length || !isUsingCurrentLocation) {
        alert("Navigation only available from current location");
        return;
      }
      
      // Open in Google Maps if on mobile
      if (navigator.userAgent.match(/Android|iPhone|iPad|iPod/i)) {
        const s = startMarker.getLatLng();
        const d = destMarker.getLatLng();
        const url = `https://www.google.com/maps/dir/?api=1&origin=${s.lat},${s.lng}&destination=${d.lat},${d.lng}&travelmode=driving`;
        window.open(url, '_blank');
      } else {
        // Start step by step navigation
        showNavStep(0);
      }
    };

    // Show navigation step
    function showNavStep(idx) {
      if (!navSteps[idx]) return;
      
      const step = navSteps[idx];
      const instruction = step.instruction || "Continue on route";
      const distance = step.distance ? `${step.distance} m` : "";
      
      routeInfo.innerHTML = `
        <b>Step ${idx+1}/${navSteps.length}</b><br>
        ${instruction}<br>
        ${distance ? `Distance: ${distance}` : ""}
        <div style="margin-top:8px">
          <button onclick="showNavStep(${idx+1 < navSteps.length ? idx+1 : 0})">Next</button>
        </div>
      `;
      
      if (step.location) {
        map.setView([step.location[1], step.location[0]], 17);
      }
    }

    // Close autocomplete dropdowns when clicking outside
    document.addEventListener('click', function(e) {
      if (!startInput.contains(e.target) && !startAutocomplete.contains(e.target)) {
        startAutocomplete.style.display = 'none';
      }
      if (!destInput.contains(e.target) && !destAutocomplete.contains(e.target)) {
        destAutocomplete.style.display = 'none';
      }
    });

    // Add after the other variable declarations
    let weatherTimer = null;

    // Add this function to get weather data
    function getWeatherData(lat, lng) {
      const weatherInfo = document.getElementById('weatherInfo');
      const weatherLocation = document.getElementById('weatherLocation');
      const weatherTemp = document.getElementById('weatherTemp');
      const weatherDesc = document.getElementById('weatherDesc');
      const weatherIcon = document.getElementById('weatherIcon');
      const weatherExtra = document.getElementById('weatherExtra');
      
      // Clear any existing timer
      if (weatherTimer) clearTimeout(weatherTimer);
      
      // OpenMeteo API URL
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current=temperature_2m,relative_humidity_2m,rain,weather_code,wind_speed_10m&timezone=auto`;
      
      fetch(url)
        .then(response => response.json())
        .then(data => {
          if (data && data.current) {
            const current = data.current;
            const temp = current.temperature_2m;
            const humidity = current.relative_humidity_2m;
            const windSpeed = current.wind_speed_10m;
            const weatherCode = current.weather_code;
            
            // Show the weather container
            weatherInfo.style.display = 'block';
            
            // Weather code to description mapping
            const weatherDescriptions = {
              0: 'Clear sky', 1: 'Mainly clear', 2: 'Partly cloudy', 3: 'Overcast',
              45: 'Fog', 48: 'Depositing rime fog',
              51: 'Light drizzle', 53: 'Moderate drizzle', 55: 'Dense drizzle',
              61: 'Slight rain', 63: 'Moderate rain', 65: 'Heavy rain',
              71: 'Slight snow', 73: 'Moderate snow', 75: 'Heavy snow',
              80: 'Slight showers', 81: 'Moderate showers', 82: 'Violent showers',
              95: 'Thunderstorm', 96: 'Thunderstorm with hail', 99: 'Thunderstorm with heavy hail'
            };
            
            // Weather code to emoji mapping
            const weatherIcons = {
              0: '‚òÄÔ∏è', 1: 'üå§Ô∏è', 2: '‚õÖ', 3: '‚òÅÔ∏è',
              45: 'üå´Ô∏è', 48: 'üå´Ô∏è',
              51: 'üå¶Ô∏è', 53: 'üå¶Ô∏è', 55: 'üåßÔ∏è',
              61: 'üåßÔ∏è', 63: 'üåßÔ∏è', 65: 'üåßÔ∏è',
              71: 'üå®Ô∏è', 73: 'üå®Ô∏è', 75: '‚ùÑÔ∏è',
              80: 'üå¶Ô∏è', 81: 'üåßÔ∏è', 82: '‚õàÔ∏è',
              95: '‚õàÔ∏è', 96: '‚õàÔ∏è', 99: '‚õàÔ∏è'
            };
            
            // Set weather data
            weatherLocation.textContent = 'Current Weather';
            weatherTemp.textContent = `${temp}¬∞C`;
            weatherDesc.textContent = weatherDescriptions[weatherCode] || 'Unknown';
            weatherIcon.innerHTML = `<div class="weather-icon">${weatherIcons[weatherCode] || 'üå°Ô∏è'}</div>`;
            weatherExtra.textContent = `Humidity: ${humidity}%, Wind: ${windSpeed} km/h`;
            
            // Get location name using reverse geocoding
            fetch(`https://api.geoapify.com/v1/geocode/reverse?lat=${lat}&lon=${lng}&apiKey=${GEOAPIFY_KEY}`)
              .then(res => res.json())
              .then(geoData => {
                if (geoData.features && geoData.features.length > 0) {
                  const props = geoData.features[0].properties;
                  const locationName = props.city || props.town || props.village || props.county || props.state;
                  if (locationName) {
                    weatherLocation.textContent = locationName;
                  }
                }
              })
              .catch(err => console.log('Error getting location name:', err));
          }
        })
        .catch(error => {
          console.error('Weather data error:', error);
          weatherInfo.style.display = 'none';
        });
        
      // Refresh weather data every 30 minutes
      weatherTimer = setTimeout(() => getWeatherData(lat, lng), 30 * 60 * 1000);
    }

    // Update map.on('moveend') event to get weather for the current map center
    map.on('moveend', function() {
      const center = map.getCenter();
      getWeatherData(center.lat, center.lng);
    });

    // Also get weather when the map first loads
    map.on('load', function() {
      const center = map.getCenter();
      getWeatherData(center.lat, center.lng);
    });

    // Add points of interest by right-clicking
    map.on('contextmenu', function(e) {
      const name = prompt('Enter location name:', 'New Location');
      if (name !== null) {
        addPointOfInterest(e.latlng.lat, e.latlng.lng, name);
      }
    });
    
    // Add points of interest when map loads
    map.on('load', function() {
      // Request initial location, which will also add a point of interest
      requestLocationFromApp('initial');
      
      // Add some example points of interest
      setTimeout(() => {
        // Add some sample points of interest
        addPointOfInterest(15.1942, 120.6132, 'Manila Cathedral', 'Historic church in Intramuros');
        addPointOfInterest(15.1842, 120.5932, 'Rizal Park', 'Historical urban park');
      }, 3000);
    });
    
    // Add information about rating to the floating card
    document.addEventListener('DOMContentLoaded', function() {
      const routeActions = document.querySelector('.route-actions');
      if (routeActions) {
        const infoDiv = document.createElement('div');
        infoDiv.innerHTML = `
          <div style="margin-top: 12px; padding: 10px; background: #f0f4ff; border-radius: 8px; font-size: 12px;">
            <p style="margin: 0; line-height: 1.4;">
              <b>Tip:</b> Right-click on map to add a location. Click any green pin to view details and rate the location.
            </p>
          </div>
        `;
        routeActions.parentNode.insertBefore(infoDiv, routeActions.nextSibling);
      }
    });
    
    // Add this to the window.onload function to initialize weather data
    window.onload = function() {
      // Try to get user location
      if (window.ReactNativeWebView) {
        requestLocationFromApp('initial');
      } else if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(pos => {
          const {latitude, longitude} = pos.coords;
          userLatLng = {lat: latitude, lng: longitude};
          map.setView([latitude, longitude], 15);
          
          // Add current location as a point of interest
          addPointOfInterest(latitude, longitude, 'My Current Location', 'Your current position');
          
          // Get weather data for current location
          getWeatherData(latitude, longitude);
          
          // If on mobile, auto-set as starting location
          if (navigator.userAgent.match(/Android|iPhone|iPad|iPod/i)) {
            startInput.value = "My location";
            setMarker(latitude, longitude, 'start', true);
            isUsingCurrentLocation = true;
            updateButtons();
          }
        }, err => {
          console.log('Location error:', err.message);
        }, {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        });
      }
      
      // Notify React Native when map is ready
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'mapReady'
        }));
      }
    };

    async function fetchLocationDetails(lat, lng) {
      try {
        // In a real implementation, this would call your API
        // For now we'll just mock some data
        const details = {
          id: Math.floor(Math.random() * 1000),
          name: 'Sample Location',
          average_rating: 4.2,
          visit_count: 15,
          recent_comments: [
            { user: { name: 'Sample User' }, rating: 4, comment: 'Great place!', created_at: new Date().toISOString() }
          ]
        };
        
        return details;
      } catch (error) {
        console.error('Error fetching location details:', error);
        return null;
      }
    }
  </script>
  <script>
    // --- Place after floatingCard and routeInfo are defined ---

    function updateRouteInfoPosition() {
      // Only adjust if routeInfo is visible
      if (routeInfo.style.display === 'block') {
        // Get floating card's height (minimized or expanded)
        const cardRect = floatingCard.getBoundingClientRect();
        // Calculate distance from bottom of viewport
        const bottomGap = window.innerHeight - cardRect.bottom;
        // Set routeInfo just above the floating card, with a small gap
        // (If floatingCard is minimized, it's smaller)
        const gap = 20; // px
        // Set bottom so that routeInfo sits above the card
        routeInfo.style.bottom = (cardRect.height + gap + bottomGap) + 'px';
      }
    }

    // Observe floating card resize/toggle
    const cardResizeObserver = new ResizeObserver(updateRouteInfoPosition);
    cardResizeObserver.observe(floatingCard);

    // Also update on toggle
    toggleBtn.addEventListener('click', function() {
      setTimeout(updateRouteInfoPosition, 350); // Wait for transition
    });

    // Also update on window resize
    window.addEventListener('resize', updateRouteInfoPosition);

    // Also update when routeInfo is shown
    const originalShowRouteInfo = function() {
      routeInfo.style.display = 'block';
      updateRouteInfoPosition();
    };
    // Patch all places where routeInfo.style.display = 'block';
    const _calculateRoute = calculateRoute;
    calculateRoute = function() {
      _calculateRoute.apply(this, arguments);
      setTimeout(updateRouteInfoPosition, 350);
    };

    // If you show routeInfo elsewhere, call updateRouteInfoPosition() after showing it.
  </script>
  <script>
    // Add this to your script section
    function showDebug(message) {
      // Create a debug element if it doesn't exist
      if (!document.getElementById('debugOutput')) {
        const debugDiv = document.createElement('div');
        debugDiv.id = 'debugOutput';
        debugDiv.style.position = 'absolute';
        debugDiv.style.top = '10px';
        debugDiv.style.left = '10px';
        debugDiv.style.backgroundColor = 'rgba(0,0,0,0.7)';
        debugDiv.style.color = 'white';
        debugDiv.style.padding = '10px';
        debugDiv.style.borderRadius = '5px';
        debugDiv.style.maxWidth = '80%';
        debugDiv.style.maxHeight = '30%';
        debugDiv.style.overflow = 'auto';
        debugDiv.style.zIndex = '9999';
        document.body.appendChild(debugDiv);
      }
      
      // Add the message
      const debugOutput = document.getElementById('debugOutput');
      const msgElement = document.createElement('div');
      msgElement.textContent = typeof message === 'object' ? JSON.stringify(message) : message;
      debugOutput.appendChild(msgElement);
      
      // Keep only the last 10 messages
      while (debugOutput.childNodes.length > 10) {
        debugOutput.removeChild(debugOutput.firstChild);
      }
    }
    
  </script>
</body>
</html>